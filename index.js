function findMissingNumbersUsingSets(numbers) {
  const missing = new Set();

  for (let i = 1; i <= numbers[numbers.length - 1]; i++) {
    missing.add(i);
  }
  console.log(missing)
  for (let number of numbers) {
    if (missing.has(number)) {
      missing.delete(number);
    }
  }

  const missingNumbers = [...missing];
  return missingNumbers;
}

console.log(findMissingNumbersUsingSets([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,55,56,57,58,59,60]))

// Создадим функцию которая будет принимать масив с последовтельными числами с двумя пропущеными числами в случайном месте,
// создадим переменную missing которая сначала будет пустой коллекцией, следующим делом создаем цикл for который добавит в массив все числа которые
// получила функция включая два пропущеных числа, дальше запускаем цикл for of который перебирает все числа в масиве который принимает функция,
// далее с помощью методов has и delete мы берем числа из полученого массива и проверяем есть ли они в колекции missing,
// если число есть, мы убираем его, в результате когда цикл закончится, мы получим массив с пропущенными числами, 
// 2) Этот метод использует найменьшую вычислительную сложность, но если масив чисел слишком большой,
// то может использовать больше памяти, вычислительная сложность в нём О(n), где n - это длинна масива
// Создание элемента missing занимает O(1) времени, цикл for перебирает все числа от 1 до последнего числа в масиве, перемещение числа і в missing с помощью add занимает O(1) времени
// Общая вычислительная сложность инициализации является O(n), ведь нужно сделать n итераций цикла, с перебором цикла numbers всё так же, 
// там тоже O(n) плюс удаление number с missing с помощью delete тоже занимает O(1) времени,
// и конвертация missing в массив тоже занимает O(n) времени который занимает времени пропорционально количеству элементов
// Худшая вычислительная сложность алгоритма определяется инициализацией и конвертацией множественного числа в массив, ведь эти операции занимают O(n) времени.
// Общая вычислительная сложность составляет O(n), где n – длина массива numbers.